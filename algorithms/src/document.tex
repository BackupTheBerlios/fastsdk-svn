\documentclass{article}

\usepackage[headings]{fullpage}
\usepackage{verbatim}
\usepackage{amssymb,amsmath}
\usepackage{CJK}
\usepackage[bookmarks=false, dvipdfm, pdfstartview=FitH, colorlinks=true,
bookmarksnumbered=true, linkcolor=black]{hyperref}
\textheight 9.0in

\begin{document}
\begin{CJK}{GBK}{song}

\title{算法设计与分析复习参考}
\author{沈容舟 anticlockwise5@gmail.com}
\date{2006年6月6日}

\maketitle

\tableofcontents

\newpage

\section{O, $\Omega$, $\Theta$ 的具体定义}
以下设f(N)和g(N)是定义在正数集上的正函数。

如果存在正的常数C和自然数N$_{0}$，使得当N$\ge$N$_{0}$时有f(N)$\le$Cg(N)，则称
函数f(N)当N充分大时上有界，且g(N)是它的一个上界，记为f(N)=O(g(N))。这时
还说f(N)的阶不高于g(N)的阶。

如果存在正的常数C和自然数N$_{0}$，使得当N$\ge$N$_{0}$时，有f(N)$\ge$Cg(N)，
则称函数f(N)当N充分大时下有界；且g(N)是它的一个下界，记为f(N)=$\Omega$(g(N))。

\section{最坏情况下复杂度和平均情况下复杂度}
\begin{enumerate}
  \item 最坏情况下的时间复杂度：$T\max{(n)} = \max{\lbrace T(N,I)|size(I)=n \rbrace}$
  \item 最好情况下的时间复杂度：$T\min{(n)} = \min{\lbrace T(N,I)|size(I)=n \rbrace}$
  \item 平均情况下的时间复杂度：$\displaystyle{Tavg(n) = \sum_{size(I)=n}{p(I)T(I)}}$
\end{enumerate}

\section{递归}
\subsection{定义}
直接或间接的调用自身的算法称为\textbf{递归算法}。用函数自身给出定义的
函数称为\textbf{递归函数}。

\subsection{递归算法二要素}
\begin{enumerate}
  \item 递归边界条件。
  \item 递归定义：使问题向边界条件转化的规则。
\end{enumerate}

\section{背包问题与0-1背包问题的区别}
\begin{itemize}
  \item 共同点：给定n种物品和一个背包。物品i的重量是$W_{i}$，其价值为$V_{i}$，背包的容量为C。
应如何选择装入背包的物品，使得装入背包种物品的总价值最大。
  \item 不同点：\begin{enumerate}
              \item 对于0-1背包问题，在选择装入背包的物品时，对每种物品i只有2种选择，
              即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。
              \item 对于背包问题，物品装入时，可以装入部分物品。
            \end{enumerate}
\end{itemize}

\section{分治法与动态规划之间的异同}
\begin{itemize}
  \item 相同点：基本思想相同，即都是将待求解问题分解成若干个子问题，先求解自问题，然后从这些
  子问题的解得到原问题的解。
  \item 不同点：适合于用动态规划求解的问题，经分解得到的子问题往往不是互相对立的。
\end{itemize}

\section{回溯分治法与分支限界法的异同}
\begin{itemize}
  \item 相同点：都是在问题的解空间上搜索问题解得算法
  \item 不同点：\begin{enumerate}
              \item 求解目标区别：回溯法的求解目标是找出解空间树种满足约束条件的\textbf{所有解}，
              而分支限界法的求解目标则是找出满足约束条件的\textbf{一个解}，或是在满足约束条件的
              解中找出在某种意义下的\textbf{最优解}。
              \item 搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度
              优先或以最小耗费优先的方式搜索解空间树。
            \end{enumerate}
\end{itemize}

\section{动态规划问题的特征}
\begin{itemize}
  \item 最优子结构性质：问题的最优解包含了其子问题的最优解。
  \item 子问题重叠性质：在求解问题时，每次产生的子问题并不一定完全是新的或者独立的问题，
  而有一些子问题是重复计算的。
\end{itemize}

\section{回溯法中的剪枝函数}
\begin{itemize}
  \item 约束函数：用来在扩展结点处剪去不满足约束的子树；
  \item 限界函数：用来剪去得不到最优解的子树。
\end{itemize}

\section{非确定性图灵机与确定性图灵机的主要区别}
\begin{itemize}
  \item 确定性图灵机：在图灵机计算模型中，移动函数$\delta$是单值的，即对于$Q\times Tk$中的每一个值，
当它属于$\delta$的定义域时，$Q\times(T\times\lbrace L, R, S\rbrace)k$中只有唯一的值与之对应，
称这种图灵机为确定性图灵机，简记为DTM(Deterministic Turing Machine)。
  \item 非确定性图灵机：一个k带的非确定性图灵机M是一个7元组：(Q, T, I, $\delta$, b, $q_{0}$, $q_{f}$)。
与确定性图灵机不同的是非确定性图灵机允许移动函数$\delta$具有不确定性，即对于$Q\times Tk$中的每一个
值$(q;x_{1}, x_{2}, \hdots, x_{k})$，当它属于$\delta$的定义域时，$Q\times(T\times\lbrace L,
R, S\rbrace)k$中有唯一的一个子集$\delta (q;x_{1}, x_{2}, \hdots, x_{k})$与之对应。可以在
$\delta (q;x_{1}, x_{2}, \hdots, x_{k})$中随意选定一个值作为他的函数值。
\end{itemize}

\section{P类与NP类语言}
问题P是多项式（时间）界的，是指问题P有一个多项式（时间）界的算法。
问题P一般称为P类问题，或易解问题。

一般的说，将可由多项式时间算法求解的问题看作是\textbf{易处理的问题}，
而将需要超多项式时间才能求解的问题看作是\textbf{难处理的问题}。

\subsection{P类和NP类语言的定义}
$P = \lbrace \text{L${|}$L是一个能在多项式时间内被一台DTM所接受的语言}\rbrace$ \\
$NP = \lbrace \text{L${|}$L是一个能在多项式时间内被一台NDTM所接受的语言}\rbrace$

\section{旅行售货员问题}
\subsection{算法描述}
算法中while循环的终止条件是排列树的一个叶结点成为当前扩展结点。
当s=n-1时，以找到的回路前缀是$x[0:n-1]$，它已包含图G的所有n个顶点。
因此，当s=n-1时，相应的扩展结点表示一个叶结点。
此时该叶结点所相应的回路的费用等于cc和lcost的值。
剩余的活结点的lcost值不小于以找到的回路的费用。
它们都不可能导致费用更小的回路。
因此已找到的叶结点所相应的回路是一个最小费用旅行售货员回路，算法可以结束。

算法结束时返回找到的最小费用，相应的最优解有数组v给出。

\subsubsection{队列式分支限界法}
$[\underline{A}]B, C, D$ \\
$[\underline{B}, C, D]E, F$ \\
$[\underline{C}, D, E, F]G, H$ \\
$[\underline{D}, E, F, G, H]I, J$ \\
$[\underline{E}, F, G, H, I, J]K(59)[1, 2, 3, 4]$ \\
$[\underline{F}, G, H, I, J]L(66)$ \\
$[\underline{G}, H, I, J]M(25)[1, 3, 2, 4]$ \\
$[\underline{H}, I, J]1-3-4(26)$ \\
$[\underline{I}, J]O(25)$ \\
$[\underline{J}]P(59)$

\subsubsection{优先队列式分支限界法}
$[\underline{A}]B, C, D \rightarrow B(30), C(6), (4)$ \\
$[\underline{D}, C, B]I, J \rightarrow I(14), J(24)$ \\
$[\underline{C}, I, J, B]G, H \rightarrow G(11), H(26)$ \\
$[\underline{G}, I, J, B, H]M \rightarrow M(25)[1, 2, 3, 4]$ \\
$[\underline{I}, J, B, H]O \rightarrow O(25)$ \\
$[\underline{J}, B, H]P \rightarrow P(59)$ \\
$[\underline{B}, H]B, H\text{限界掉}$

\section{0-1 背包问题}
0-1背包问题：给定n种物品和一个背包。物品i的重量是$w_{i}$，
其价值为$v_{i}$，背包的容量为C。问：应该如何选择装入背包的物品，
使得装入背包种物品的总价值最大？

在选择装入背包的物品时，对每种物品i只有两种选择，即装入背包或不装入背包。
不能将物品i装入背包多次，也不能只装入部分的物品i。

\subsection{最优子结构性质}
0-1背包问题具有最优子结构性质。设$(y_{1}, y_{2}, \hdots, y_{n})$是所给0-1背包问题的一个最优解，
则$(y_{2}, \hdots, y_{n})$是下面相应子问题的一个最优解：
\begin{align*}
&\max{\sum_{i=2}^{n}{v_{i}x_{i}}} \\
&\begin{cases}
\displaystyle{\sum_{i=2}^{n}{w_{i}x_{i}}} \le C \\
x_{i} \in \lbrace 0, 1\rbrace, 2 \le i \le n
\end{cases}
\end{align*}

因若不然，设$(z_{2}, \hdots, z_{n})$是上述子问题的一个最优解，
而$(y_{2}, \hdots, y_{n})$不是它的最优解。
由此可知，\\
$\displaystyle{\sum_{i=2}^{n}{v_{i}z_{i}} > \sum_{i=2}^{n}{v_{i}y_{i}}}$，
且$\displaystyle{w_{1}y_{1} + \sum_{i=2}^{n}{w_{i}z_{i}} \le C}$。因此

\begin{align*}
& v_{1}y_{1} + \sum_{i=2}^{n}{v_{i}z_{i}} > \sum_{i=2}^{n}{v_{i}y_{i}} \\
& w_{1}y_{1} + \sum_{i=2}^{n}{w_{i}z_{i}} \le C
\end{align*}
这说明$(z_{1}, z_{2}, \hdots, z_{n})$时所给0-1背包问题的更优解，
从而$(y_{1}, y_{2}, \hdots, y_{n})$不是所给0-1背包问题的最优解。
此为矛盾。

\subsection{递归关系}
设所给0-1背包问题的子问题

\begin{align*}
&\max{\sum_{k=i}^{n}{v_{k}x_{k}}} \\
&\begin{cases}
\displaystyle{\sum_{k=i}^{n}{w_{k}x_{k}}} \le j \\
x_{i} \in \lbrace 0, 1\rbrace, i \le k \le n
\end{cases}
\end{align*}
的最优解为$m(i, j)$，即$m(i, j)$是背包容量为j, 
可选择物品为$i, i+1, \hdots, n$时0-1背包问题的最优解。由0-1背包问题
的最优子结构性质，可以建立计算$m(i, j)$的递归式如下：
\begin{align*}
&m(i, j) = \begin{cases}
		   \max{\lbrace m(i+1, j), m(i+1, j-w_{i}) + v_{i}\rbrace} & j \ge w_{i}\\
		   m(i+1, j) & 0 \le j < w_{i}
		   \end{cases} \\
&m(n, j) = \begin{cases}
           v_{n} & j > w_{n} \\
           0 & 0 \le j < w_{n}
           \end{cases}
\end{align*}

\subsection{划分阶段}
\begin{description}
\item[第一阶段：]只装入1个物体，确定各种不同载重量背包下，能够获得最大值。
\item[第二阶段：]装入前2个物体，确定各种不同载重量背包下，能够获得最大值。
\item[依此类推，]知道第n个阶段，最后m(n,c)便是载重量为c的背包下，装入n个物体时能够获得最大值。
\end{description}

\subsection{确定装入}
从m(n,c)的值向前倒推：$m(n,c)>m(n-1,c)$表明n物体装入背包，则问题简化为：
前n-1个物体被装入载重量为c-wn背包中。$m(n,c)\le m(n-1,c)$表明n物体未装入背包，
则问题简化为：前n-1个物体被装入载重量为c背包中。

依次类推，直道第1个物体是否被装入背包为止。可得递推关系：\\
若：$m(n,c)=m(n-1,c) & \text{则 $x_{i}=0$}$ \\
若：$m(n,c)>m(n-1,c) & \text{则 $x_{i}=1, j=j-w_{i}$}$

\subsection{例题}
设0-1背包的一个实例：n = 5, c = 10, w = $\lbrace$2, 2, 6, 5, 4$\rbrace$, v = $\lbrace$
6, 3, 5, 4, 6$\rbrace$ \\
有动态函数递推$m[][]$如下：
\begin{center}
\begin{tabular}{rlllllllllll}
i/j \vline &0&1&2&3&4&5&6&7&8&9&10 \\
\hline
0 \vline &0&0&0&0&0&0&0&0&0&0&0 \\
1 \vline &0&0&6&6&6&6&6&6&6&6&6 \\
2 \vline &0&0&6&6&9&9&9&9&9&9&9 \\
3 \vline &0&0&6&6&9&9&9&9&11&11&14 \\
4 \vline &0&0&6&6&9&9&9&10&11&13&14 \\
5 \vline &0&0&6&6&9&9&12&12&15&15&\underline{15}
\end{tabular}
\end{center}
若$m[i][j]=m[i-1][j] xi = 0$ \\
若$m[i][j]>m[i-1][j] xi = 1$ \\
故,最优解为(1, 1, 0, 0, 1)

\subsection{算法实现}
\subsubsection{动态规划求最优值}
\begin{verbatim}
void knapsack(v[], w[], c, n, x[]) {
    初始化 m[][], x[];
    for(int i = 0; i <= n; i++) {
        for(int j = 1; j <= c; j++) {
            m[i][j] = m[i-1][j];
            if(j >= w[i] && (m[i-1][j-w[i]] + v[i] > m[i-1][j])
                m[i][j] = m[i-1][j-w[i]] + v[i];
        }
    }
}
\end{verbatim}

\subsubsection{构造最优解}
\begin{verbatim}
public static void traceback(m[][], w[], c, n, x[]) {
    j = c;
    for(int i = n; i < 0; i--) {
        if(m[i][j] > m[i-1][j]) {
            x[i] = 1;
            j = j - w[i];
        }
    }
}
\end{verbatim}

\subsection{算法复杂度分析}
从m(i,j)的递归式容易看出,算法需要$O(nc)$计算时间.

当背包容量c很大时，算法需要的计算时间较多。例如当$c>2n$时，
算法需要$\Omega (n^{2})$计算时间。

\section{n后问题}
在$n\times n$的棋盘上放置彼此不受攻击的n个皇后。
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n后问题等价于在$n\times n$格的棋盘上放置n个皇后，
任何2个皇后不放在同一行或同一列或同一斜线上。

\subsection{算法描述}
\subsubsection{解向量}
$(x_{1}, x_{2}, \hdots, x_{n})$
\subsubsection{显约束}
$x_{i}$序号表示所在行，其值表示所在列。
\subsubsection{隐约束}
\begin{enumerate}
\item 不同列：$x_{i}\neq x_{j}$
\item 不处于同一正、反对角线：$|i-j| \neq |x_{i}-x_{j}|$
\end{enumerate}

\begin{verbatim}
public static boolean place(int k) {
    for(int j = 1; j < k; j++)
        if((abs(k-j) == abs(x[j]-x[k])) || (x[j] == x[k]))
            return false;
    return true;
}

public static void backtrack(int t) {
    if(t > n)
        sum++;
    else {
        for(int i = 1; i <=n; i++) {
            x[t] = i;
            if(place(t))
                backtrack(t+1);
        }
    }
}
\end{verbatim}

\section{图的m着色问题}
给定无向连通图G和m种不同的颜色。用这些颜色为图G的个顶点着色，
每个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同的颜色。
这个问题是图的m可着色判定问题。
若一个图最少需要m种颜色才能使土中每条边连接的2个顶点着不同颜色，
则称这个数m为该图的色数。
求一个图的色数m的问题称为图的m可着色优化问题。

\subsection{算法描述}
\subsubsection{解空间}
$(x_{1}, x_{2}, \hdots, x_{n})$表示顶点i所着颜色$x[i]$。
\subsubsection{可行性约束函数}
顶点i与已着色的相邻顶点颜色不重复。\\
邻接矩阵 G = (V,E) \\
$a[i,j]$ \begin{cases}
       0 & \\
       1 & \text{存在边}
       \end{cases} \\
$x[i]$ = 表示着色 \\
n = 3, m = 3解空间树 \\
n + 1层为叶结点

\begin{verbatim}
public static void backtrack(int t) {
    if(t > n) {
        sum++;
    } else {
        for(int i = 1; i <= m; i++) {
            x[t] = i;
            if(ok(t))
                backtrack(t+1);
        }
    }
}

public static boolean ok(int k) {
    for(int j = 1; j <= n; j++) {
        if(a[k][j] && (x[j] == x[k]))
            return false;
    }
}
\end{verbatim}

\subsection{算法复杂度}
图m可着色问题的解空间树中内结点个数是：$\displaystyle{\sum_{i=0}^{n-1}{m^{i}}}$对于每一个内结点，
在最坏情况下，用ok检查当前扩展结点的每一个儿子所相应的颜色可用性需耗时$O(mn)$。
因此，回溯法总的时间耗费是：
\begin{equation*}
\sum_{i=0}^{n-1}{(mn)} = \frac{nm(m^{n}-1)}{m-1} = O(nm^{n})
\end{equation*}

\section{最后一道设计题}
\subsection{思路}
将N个数组分为大致相同的两半，看x是不是在$a[N/2]$这个数组的范围内。

若在，则在$a[N/2]$这个数组通过常数次比较得出结果(有返回N/2，无返回-1)

若不在，考虑两种情况：
\begin{cases}
\text{$x > a[N/2]$中最大的数，则在$\frac{N}{2}+1 - N-1$的数组中继续查找} \\
\text{$x < a[N/2]$中的最小数，则在$0 - \frac{N}{2}-1$的数组中继续查找}
\end{cases}

\begin{verbatim}
public static int search(int a[], int n, int x) {
    for(int i = 0; i < n; i++) {
        if(a[i] == x)
            return i;
    return -1;
}

public static int divideSearch(int a[][5], int n, int x) {
    int left = 0;
    int right = n-1;
    while(left <= right) {
        int middle = (left + right) / 2;
        if((x >= a[middle][0] && x <= a[middle][4]) ||
            (x <= a[middle][0] && x >= a[middle][4]))
            return (search(a[middle], 5, x) == -1) ? -1 : middle;
        else if(x > a[middle][0] && x > a[middle][4])
            left = middle + 1;
        else
            right = middle - 1;
    }
    return -1;
}
\end{verbatim}

\subsection{算法复杂度分析}
该算法的复杂度主要在于二分查找数组，所以其时间复杂度为：$T(n) = \log_{2}{(N)}$。

\end{CJK}
\end{document}
